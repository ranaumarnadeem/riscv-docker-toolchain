#!/usr/bin/env python3
"""
rv - RISC-V Toolchain CLI Wrapper
A CLI wrapper for the RISC-V GNU Toolchain.

Designed to run inside the riscv-toolchain Docker container.
Usage:
  docker run --rm -v $(pwd):/src riscv-toolchain rv build test.c --arch 32imac
  docker run --rm -it -v $(pwd):/src riscv-toolchain  # Interactive shell, then use rv commands

Can be used as:
- Single command: rv build test.c --arch 32imac
- Interactive REPL: rv (then type commands)
"""

import argparse
import os
import shlex
import subprocess
import sys
from pathlib import Path

# readline is optional (not available on Windows by default)
try:
    import readline
    HAS_READLINE = True
except ImportError:
    HAS_READLINE = False

# Tool prefix for Alpine's RISC-V toolchain
TOOL_PREFIX = "riscv-none-elf-"

# Architecture presets: maps shorthand to (march, mabi)
ARCH_PRESETS = {
    # 32-bit architectures
    "32i":       ("rv32i",       "ilp32"),
    "32im":      ("rv32im",      "ilp32"),
    "32ima":     ("rv32ima",     "ilp32"),
    "32imac":    ("rv32imac",    "ilp32"),
    "32imafc":   ("rv32imafc",   "ilp32f"),
    "32imafdc":  ("rv32imafdc",  "ilp32d"),
    # 64-bit architectures
    "64i":       ("rv64i",       "lp64"),
    "64im":      ("rv64im",      "lp64"),
    "64ima":     ("rv64ima",     "lp64"),
    "64imac":    ("rv64imac",    "lp64"),
    "64imafc":   ("rv64imafc",   "lp64f"),
    "64imafdc":  ("rv64imafdc",  "lp64d"),
}

# Valid optimization levels
OPT_LEVELS = ["O0", "O1", "O2", "O3", "Os", "Oz"]


def run_command(cmd: list[str], capture: bool = False) -> subprocess.CompletedProcess:
    """Run a command and handle errors."""
    try:
        if capture:
            result = subprocess.run(cmd, capture_output=True, text=True)
        else:
            result = subprocess.run(cmd)
        return result
    except FileNotFoundError:
        print(f"Error: Command '{cmd[0]}' not found.")
        print("Make sure you're running inside the RISC-V toolchain container.")
        sys.exit(1)


def get_arch_abi(arch_str: str) -> tuple[str, str]:
    """
    Convert architecture string to (march, mabi) tuple.
    Supports presets (e.g., '32imac') or custom (e.g., '32imc_zba_zbb').
    """
    # Check if it's a preset
    if arch_str in ARCH_PRESETS:
        return ARCH_PRESETS[arch_str]
    
    # Custom architecture - infer ABI from the string
    # Expected format: 32<ext> or 64<ext> (e.g., 32imc_zba_zbb, 64imac_zba)
    if arch_str.startswith("32"):
        march = f"rv{arch_str}"
        # Determine ABI based on floating-point extensions
        if "d" in arch_str.split("_")[0]:  # Check base arch for 'd'
            mabi = "ilp32d"
        elif "f" in arch_str.split("_")[0]:  # Check base arch for 'f'
            mabi = "ilp32f"
        else:
            mabi = "ilp32"
        return (march, mabi)
    elif arch_str.startswith("64"):
        march = f"rv{arch_str}"
        # Determine ABI based on floating-point extensions
        if "d" in arch_str.split("_")[0]:
            mabi = "lp64d"
        elif "f" in arch_str.split("_")[0]:
            mabi = "lp64f"
        else:
            mabi = "lp64"
        return (march, mabi)
    else:
        print(f"Error: Invalid architecture '{arch_str}'.")
        print("Architecture must start with '32' or '64' (e.g., 32imac, 64imafdc, 32imc_zba_zbb)")
        sys.exit(1)


def cmd_build(args):
    """Build (compile) a C file to ELF."""
    source = Path(args.file)
    
    if not source.exists():
        print(f"Error: Source file '{source}' not found.")
        sys.exit(1)
    
    # Determine output path
    if args.output:
        output = Path(args.output)
    else:
        build_dir = Path("build")
        build_dir.mkdir(exist_ok=True)
        output = build_dir / f"{source.stem}.elf"
    
    # Ensure output directory exists
    output.parent.mkdir(parents=True, exist_ok=True)
    
    # Get architecture and ABI
    march, mabi = get_arch_abi(args.arch)
    
    # For bare-metal, add zicsr extension if not already present (needed for CSR instructions in startup code)
    if args.bare and "_zicsr" not in march and "zicsr" not in march:
        march = march + "_zicsr"
    
    # Determine if 32-bit or 64-bit
    is_64bit = args.arch.startswith("64")
    
    # Validate optimization level
    opt = args.opt if args.opt.startswith("O") else f"O{args.opt}"
    if opt.upper() not in [o.upper() for o in OPT_LEVELS]:
        print(f"Error: Invalid optimization level '{args.opt}'.")
        print(f"Valid options: {', '.join(OPT_LEVELS)}")
        sys.exit(1)
    
    # Build GCC command
    gcc = f"{TOOL_PREFIX}gcc"
    cmd = [
        gcc,
        f"-march={march}",
        f"-mabi={mabi}",
        f"-{opt}",
        "-g",
    ]
    
    # Handle bare-metal vs hosted build
    if args.bare:
        # Bare-metal: use custom linker script and startup code
        ld_script = f"/usr/local/share/riscv/riscv{'64' if is_64bit else '_32'}.ld"
        crt0 = f"/usr/local/share/riscv/crt0_{'64' if is_64bit else '32'}.S"
        
        cmd.extend([
            "-nostartfiles",
            "-ffreestanding",
            f"-T{ld_script}",
            crt0,
        ])
        build_mode = "bare-metal"
    else:
        # Hosted: use newlib
        cmd.append("--specs=nosys.specs")
        build_mode = "hosted (newlib)"
    
    cmd.extend([str(source), "-o", str(output)])
    
    # Add extra cflags if provided
    if args.cflags:
        # Split cflags string into individual flags
        cmd.extend(args.cflags.split())
    
    print(f"Compiling {source} -> {output}")
    print(f"  Architecture: {march}, ABI: {mabi}, Optimization: -{opt}")
    print(f"  Mode: {build_mode}")
    
    result = run_command(cmd)
    
    if result.returncode == 0:
        print(f"Success: {output}")
    else:
        sys.exit(result.returncode)


def cmd_bin(args):
    """Convert ELF file to raw binary."""
    elf_file = Path(args.file)
    
    if not elf_file.exists():
        print(f"Error: ELF file '{elf_file}' not found.")
        sys.exit(1)
    
    # Determine output path
    if args.output:
        output = Path(args.output)
    else:
        output = elf_file.with_suffix(".bin")
    
    # Ensure output directory exists
    output.parent.mkdir(parents=True, exist_ok=True)
    
    objcopy = f"{TOOL_PREFIX}objcopy"
    cmd = [
        objcopy,
        "-O", "binary",
        str(elf_file),
        str(output)
    ]
    
    print(f"Converting {elf_file} -> {output}")
    result = run_command(cmd)
    
    if result.returncode == 0:
        # Show file size
        size = output.stat().st_size
        print(f"Success: {output} ({size} bytes)")
    else:
        sys.exit(result.returncode)


def cmd_dump(args):
    """Disassemble an ELF file using objdump."""
    elf_file = Path(args.file)
    
    if not elf_file.exists():
        print(f"Error: ELF file '{elf_file}' not found.")
        sys.exit(1)
    
    objdump = f"{TOOL_PREFIX}objdump"
    cmd = [objdump, "-d", str(elf_file)]
    
    if args.grep:
        # Run objdump and filter output
        result = run_command(cmd, capture=True)
        if result.returncode != 0:
            print(result.stderr)
            sys.exit(result.returncode)
        
        lines = result.stdout.splitlines()
        matches = [line for line in lines if args.grep in line]
        
        if matches:
            print(f"Found {len(matches)} match(es) for '{args.grep}':")
            for line in matches:
                print(line)
        else:
            print(f"No matches found for '{args.grep}'")
    else:
        # Just run objdump directly
        result = run_command(cmd)
        sys.exit(result.returncode)


def cmd_version(args):
    """Show toolchain version information."""
    print("RISC-V Toolchain Versions:")
    print("-" * 40)
    
    # GCC version
    gcc = f"{TOOL_PREFIX}gcc"
    print(f"\n{gcc}:")
    run_command([gcc, "--version"])
    
    # Binutils version (via ld)
    ld = f"{TOOL_PREFIX}ld"
    print(f"\n{ld}:")
    run_command([ld, "--version"])


def cmd_archs(args):
    """List supported architecture presets."""
    print("Supported Architecture Presets:")
    print("=" * 60)
    print(f"{'Preset':<15} {'--march':<20} {'--mabi':<10}")
    print("-" * 60)
    
    print("\n32-bit architectures:")
    for name, (march, mabi) in ARCH_PRESETS.items():
        if name.startswith("32"):
            print(f"  {name:<13} {march:<20} {mabi:<10}")
    
    print("\n64-bit architectures:")
    for name, (march, mabi) in ARCH_PRESETS.items():
        if name.startswith("64"):
            print(f"  {name:<13} {march:<20} {mabi:<10}")
    
    print("\n" + "=" * 60)
    print("Custom architectures:")
    print("  You can also use custom arch strings like:")
    print("    --arch 32imc_zba_zbb  (RV32 with bit manipulation)")
    print("    --arch 64imac_zba     (RV64 with address generation)")
    print("\n  The ABI is automatically inferred from the architecture.")


def cmd_build_image(args):
    """Show instructions for building the Docker image."""
    print("To build the Docker image, run from the host:")
    print()
    print("  docker build -t riscv-toolchain .")
    print()
    print("Then run the container:")
    print("  docker run --rm -v $(pwd):/src riscv-toolchain rv build <file> --arch <arch>")
    print("  docker run --rm -it -v $(pwd):/src riscv-toolchain  # Interactive shell")
    sys.exit(0)


def create_parser():
    """Create and return the argument parser."""
    parser = argparse.ArgumentParser(
        prog="rv",
        description="RISC-V Toolchain CLI Wrapper (runs inside Docker container)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  rv build test.c --arch 32imac
  rv build test.c --arch 32imac -o output.elf --opt O0
  rv build test.c --arch 32imc_zba_zbb --cflags "-DDEBUG -Wall"
  rv dump build/test.elf
  rv dump build/test.elf --grep clz
  rv bin build/test.elf               # Convert ELF to raw binary
  rv bin build/test.elf -o fw.bin     # Custom output name
  rv archs                            # List architectures
  rv version                          # Show toolchain version
  rv build-image                      # Show Docker build instructions

Bare-metal build:
  rv build test.c --arch 32imac --bare        # Uses included linker script & startup
  rv bin build/test.elf                       # Convert to flashable binary

Interactive mode:
  rv                                  # Start interactive REPL
  Then type commands directly: build test.c --arch 32imac

Running from host:
  docker run --rm -v $(pwd):/src riscv-toolchain rv build test.c --arch 32imac
  docker run --rm -it -v $(pwd):/src riscv-toolchain  # Interactive shell
        """
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # build command
    build_parser = subparsers.add_parser("build", help="Compile C source to ELF")
    build_parser.add_argument("file", help="Source file to compile (e.g., test.c)")
    build_parser.add_argument(
        "--arch", 
        required=True,
        help="Target architecture (e.g., 32imac, 64imafdc, 32imc_zba_zbb)"
    )
    build_parser.add_argument(
        "-o", "--output",
        help="Output file path (default: build/<filename>.elf)"
    )
    build_parser.add_argument(
        "--opt",
        default="O2",
        help="Optimization level: O0, O1, O2, O3, Os, Oz (default: O2)"
    )
    build_parser.add_argument(
        "--bare",
        action="store_true",
        help="Bare-metal build (no libc, uses included linker script and startup code)"
    )
    build_parser.add_argument(
        "--cflags",
        help="Additional compiler flags (e.g., \"--cflags '-DDEBUG -Wall'\")"
    )
    build_parser.set_defaults(func=cmd_build)
    
    # dump command
    dump_parser = subparsers.add_parser("dump", help="Disassemble ELF file")
    dump_parser.add_argument("file", help="ELF file to disassemble")
    dump_parser.add_argument(
        "--grep",
        help="Filter output for lines containing this pattern"
    )
    dump_parser.set_defaults(func=cmd_dump)
    
    # bin command
    bin_parser = subparsers.add_parser("bin", help="Convert ELF to raw binary")
    bin_parser.add_argument("file", help="ELF file to convert")
    bin_parser.add_argument(
        "-o", "--output",
        help="Output file path (default: <filename>.bin)"
    )
    bin_parser.set_defaults(func=cmd_bin)
    
    # version command
    version_parser = subparsers.add_parser("version", help="Show toolchain versions")
    version_parser.set_defaults(func=cmd_version)
    
    # archs command
    archs_parser = subparsers.add_parser("archs", help="List supported architectures")
    archs_parser.set_defaults(func=cmd_archs)
    
    # build-image command
    build_image_parser = subparsers.add_parser("build-image", help="Show Docker build instructions")
    build_image_parser.set_defaults(func=cmd_build_image)
    
    return parser


def execute_command(parser, cmd_args: list[str]) -> int:
    """Execute a single command. Returns exit code."""
    try:
        args = parser.parse_args(cmd_args)
    except SystemExit:
        return 1
    
    if args.command is None:
        parser.print_help()
        return 0
    
    # Run commands directly
    try:
        args.func(args)
        return 0
    except SystemExit as e:
        return e.code if e.code else 0


def print_repl_banner():
    """Print the REPL welcome banner."""
    print()
    print("=" * 60)
    print("  RISC-V Toolchain CLI - Interactive Mode")
    print("=" * 60)
    print()
    print("Commands:")
    print("  build <file> --arch <arch>   Compile C to ELF")
    print("  bin <file.elf>               Convert ELF to binary")
    print("  dump <file.elf> [--grep X]   Disassemble ELF")
    print("  archs                        List architectures")
    print("  version                      Show toolchain version")
    print("  help                         Show full help")
    print("  exit / quit                  Exit REPL")
    print()


def run_repl():
    """Run the interactive REPL."""
    parser = create_parser()
    
    print_repl_banner()
    
    # Set up readline for history
    try:
        readline.read_history_file()
    except (FileNotFoundError, PermissionError):
        pass
    
    while True:
        try:
            # Show prompt
            user_input = input("rv> ").strip()
            
            # Skip empty lines
            if not user_input:
                continue
            
            # Handle exit commands
            if user_input.lower() in ["exit", "quit", "q"]:
                print("Goodbye!")
                break
            
            # Handle help command
            if user_input.lower() == "help":
                parser.print_help()
                continue
            
            # Handle clear command
            if user_input.lower() in ["clear", "cls"]:
                os.system('cls' if sys.platform == 'win32' else 'clear')
                continue
            
            # Parse and execute the command
            try:
                cmd_args = shlex.split(user_input)
            except ValueError as e:
                print(f"Error: Invalid command syntax: {e}")
                continue
            
            execute_command(parser, cmd_args)
            print()  # Add blank line after command output
            
        except KeyboardInterrupt:
            print("\n(Use 'exit' or 'quit' to leave)")
        except EOFError:
            print("\nGoodbye!")
            break
    
    # Save history
    try:
        readline.write_history_file()
    except (FileNotFoundError, PermissionError):
        pass


def main():
    # If no arguments, start REPL
    if len(sys.argv) == 1:
        run_repl()
        return
    
    parser = create_parser()
    exit_code = execute_command(parser, sys.argv[1:])
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
